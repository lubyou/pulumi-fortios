// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package fortios

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Configure FortiSwitch QoS IP precedence/DSCP.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-fortios/sdk/go/fortios"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := fortios.NewSwitchControllerQosIpDscpMap(ctx, "trname", &fortios.SwitchControllerQosIpDscpMapArgs{
// 			Description: pulumi.String("DEIW"),
// 			Maps: SwitchControllerQosIpDscpMapMapArray{
// 				&SwitchControllerQosIpDscpMapMapArgs{
// 					CosQueue: pulumi.Int(3),
// 					Diffserv: pulumi.String("CS0 CS1 AF11"),
// 					Name:     pulumi.String("1"),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// SwitchControllerQos IpDscpMap can be imported using any of these accepted formats$ export "FORTIOS_IMPORT_TABLE"="true"
//
// ```sh
//  $ pulumi import fortios:index/switchControllerQosIpDscpMap:SwitchControllerQosIpDscpMap labelname {{name}}
// ```
//
//  $ unset "FORTIOS_IMPORT_TABLE"
type SwitchControllerQosIpDscpMap struct {
	pulumi.CustomResourceState

	// Description of the ip-dscp map name.
	Description pulumi.StringOutput `pulumi:"description"`
	// true or false, set this parameter to true when using dynamic forEach + toset to configure and sort sub-tables, please do not set this parameter when configuring static sub-tables.
	DynamicSortSubtable pulumi.StringPtrOutput `pulumi:"dynamicSortSubtable"`
	// Maps between IP-DSCP value to COS queue. The structure of `map` block is documented below.
	Maps SwitchControllerQosIpDscpMapMapArrayOutput `pulumi:"maps"`
	// Dscp mapping entry name.
	Name pulumi.StringOutput `pulumi:"name"`
	// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
	Vdomparam pulumi.StringPtrOutput `pulumi:"vdomparam"`
}

// NewSwitchControllerQosIpDscpMap registers a new resource with the given unique name, arguments, and options.
func NewSwitchControllerQosIpDscpMap(ctx *pulumi.Context,
	name string, args *SwitchControllerQosIpDscpMapArgs, opts ...pulumi.ResourceOption) (*SwitchControllerQosIpDscpMap, error) {
	if args == nil {
		args = &SwitchControllerQosIpDscpMapArgs{}
	}

	opts = pkgResourceDefaultOpts(opts)
	var resource SwitchControllerQosIpDscpMap
	err := ctx.RegisterResource("fortios:index/switchControllerQosIpDscpMap:SwitchControllerQosIpDscpMap", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSwitchControllerQosIpDscpMap gets an existing SwitchControllerQosIpDscpMap resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSwitchControllerQosIpDscpMap(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SwitchControllerQosIpDscpMapState, opts ...pulumi.ResourceOption) (*SwitchControllerQosIpDscpMap, error) {
	var resource SwitchControllerQosIpDscpMap
	err := ctx.ReadResource("fortios:index/switchControllerQosIpDscpMap:SwitchControllerQosIpDscpMap", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SwitchControllerQosIpDscpMap resources.
type switchControllerQosIpDscpMapState struct {
	// Description of the ip-dscp map name.
	Description *string `pulumi:"description"`
	// true or false, set this parameter to true when using dynamic forEach + toset to configure and sort sub-tables, please do not set this parameter when configuring static sub-tables.
	DynamicSortSubtable *string `pulumi:"dynamicSortSubtable"`
	// Maps between IP-DSCP value to COS queue. The structure of `map` block is documented below.
	Maps []SwitchControllerQosIpDscpMapMap `pulumi:"maps"`
	// Dscp mapping entry name.
	Name *string `pulumi:"name"`
	// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
	Vdomparam *string `pulumi:"vdomparam"`
}

type SwitchControllerQosIpDscpMapState struct {
	// Description of the ip-dscp map name.
	Description pulumi.StringPtrInput
	// true or false, set this parameter to true when using dynamic forEach + toset to configure and sort sub-tables, please do not set this parameter when configuring static sub-tables.
	DynamicSortSubtable pulumi.StringPtrInput
	// Maps between IP-DSCP value to COS queue. The structure of `map` block is documented below.
	Maps SwitchControllerQosIpDscpMapMapArrayInput
	// Dscp mapping entry name.
	Name pulumi.StringPtrInput
	// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
	Vdomparam pulumi.StringPtrInput
}

func (SwitchControllerQosIpDscpMapState) ElementType() reflect.Type {
	return reflect.TypeOf((*switchControllerQosIpDscpMapState)(nil)).Elem()
}

type switchControllerQosIpDscpMapArgs struct {
	// Description of the ip-dscp map name.
	Description *string `pulumi:"description"`
	// true or false, set this parameter to true when using dynamic forEach + toset to configure and sort sub-tables, please do not set this parameter when configuring static sub-tables.
	DynamicSortSubtable *string `pulumi:"dynamicSortSubtable"`
	// Maps between IP-DSCP value to COS queue. The structure of `map` block is documented below.
	Maps []SwitchControllerQosIpDscpMapMap `pulumi:"maps"`
	// Dscp mapping entry name.
	Name *string `pulumi:"name"`
	// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
	Vdomparam *string `pulumi:"vdomparam"`
}

// The set of arguments for constructing a SwitchControllerQosIpDscpMap resource.
type SwitchControllerQosIpDscpMapArgs struct {
	// Description of the ip-dscp map name.
	Description pulumi.StringPtrInput
	// true or false, set this parameter to true when using dynamic forEach + toset to configure and sort sub-tables, please do not set this parameter when configuring static sub-tables.
	DynamicSortSubtable pulumi.StringPtrInput
	// Maps between IP-DSCP value to COS queue. The structure of `map` block is documented below.
	Maps SwitchControllerQosIpDscpMapMapArrayInput
	// Dscp mapping entry name.
	Name pulumi.StringPtrInput
	// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
	Vdomparam pulumi.StringPtrInput
}

func (SwitchControllerQosIpDscpMapArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*switchControllerQosIpDscpMapArgs)(nil)).Elem()
}

type SwitchControllerQosIpDscpMapInput interface {
	pulumi.Input

	ToSwitchControllerQosIpDscpMapOutput() SwitchControllerQosIpDscpMapOutput
	ToSwitchControllerQosIpDscpMapOutputWithContext(ctx context.Context) SwitchControllerQosIpDscpMapOutput
}

func (*SwitchControllerQosIpDscpMap) ElementType() reflect.Type {
	return reflect.TypeOf((**SwitchControllerQosIpDscpMap)(nil)).Elem()
}

func (i *SwitchControllerQosIpDscpMap) ToSwitchControllerQosIpDscpMapOutput() SwitchControllerQosIpDscpMapOutput {
	return i.ToSwitchControllerQosIpDscpMapOutputWithContext(context.Background())
}

func (i *SwitchControllerQosIpDscpMap) ToSwitchControllerQosIpDscpMapOutputWithContext(ctx context.Context) SwitchControllerQosIpDscpMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SwitchControllerQosIpDscpMapOutput)
}

// SwitchControllerQosIpDscpMapArrayInput is an input type that accepts SwitchControllerQosIpDscpMapArray and SwitchControllerQosIpDscpMapArrayOutput values.
// You can construct a concrete instance of `SwitchControllerQosIpDscpMapArrayInput` via:
//
//          SwitchControllerQosIpDscpMapArray{ SwitchControllerQosIpDscpMapArgs{...} }
type SwitchControllerQosIpDscpMapArrayInput interface {
	pulumi.Input

	ToSwitchControllerQosIpDscpMapArrayOutput() SwitchControllerQosIpDscpMapArrayOutput
	ToSwitchControllerQosIpDscpMapArrayOutputWithContext(context.Context) SwitchControllerQosIpDscpMapArrayOutput
}

type SwitchControllerQosIpDscpMapArray []SwitchControllerQosIpDscpMapInput

func (SwitchControllerQosIpDscpMapArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SwitchControllerQosIpDscpMap)(nil)).Elem()
}

func (i SwitchControllerQosIpDscpMapArray) ToSwitchControllerQosIpDscpMapArrayOutput() SwitchControllerQosIpDscpMapArrayOutput {
	return i.ToSwitchControllerQosIpDscpMapArrayOutputWithContext(context.Background())
}

func (i SwitchControllerQosIpDscpMapArray) ToSwitchControllerQosIpDscpMapArrayOutputWithContext(ctx context.Context) SwitchControllerQosIpDscpMapArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SwitchControllerQosIpDscpMapArrayOutput)
}

// SwitchControllerQosIpDscpMapMapInput is an input type that accepts SwitchControllerQosIpDscpMapMap and SwitchControllerQosIpDscpMapMapOutput values.
// You can construct a concrete instance of `SwitchControllerQosIpDscpMapMapInput` via:
//
//          SwitchControllerQosIpDscpMapMap{ "key": SwitchControllerQosIpDscpMapArgs{...} }
type SwitchControllerQosIpDscpMapMapInput interface {
	pulumi.Input

	ToSwitchControllerQosIpDscpMapMapOutput() SwitchControllerQosIpDscpMapMapOutput
	ToSwitchControllerQosIpDscpMapMapOutputWithContext(context.Context) SwitchControllerQosIpDscpMapMapOutput
}

type SwitchControllerQosIpDscpMapMap map[string]SwitchControllerQosIpDscpMapInput

func (SwitchControllerQosIpDscpMapMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SwitchControllerQosIpDscpMap)(nil)).Elem()
}

func (i SwitchControllerQosIpDscpMapMap) ToSwitchControllerQosIpDscpMapMapOutput() SwitchControllerQosIpDscpMapMapOutput {
	return i.ToSwitchControllerQosIpDscpMapMapOutputWithContext(context.Background())
}

func (i SwitchControllerQosIpDscpMapMap) ToSwitchControllerQosIpDscpMapMapOutputWithContext(ctx context.Context) SwitchControllerQosIpDscpMapMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SwitchControllerQosIpDscpMapMapOutput)
}

type SwitchControllerQosIpDscpMapOutput struct{ *pulumi.OutputState }

func (SwitchControllerQosIpDscpMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SwitchControllerQosIpDscpMap)(nil)).Elem()
}

func (o SwitchControllerQosIpDscpMapOutput) ToSwitchControllerQosIpDscpMapOutput() SwitchControllerQosIpDscpMapOutput {
	return o
}

func (o SwitchControllerQosIpDscpMapOutput) ToSwitchControllerQosIpDscpMapOutputWithContext(ctx context.Context) SwitchControllerQosIpDscpMapOutput {
	return o
}

type SwitchControllerQosIpDscpMapArrayOutput struct{ *pulumi.OutputState }

func (SwitchControllerQosIpDscpMapArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SwitchControllerQosIpDscpMap)(nil)).Elem()
}

func (o SwitchControllerQosIpDscpMapArrayOutput) ToSwitchControllerQosIpDscpMapArrayOutput() SwitchControllerQosIpDscpMapArrayOutput {
	return o
}

func (o SwitchControllerQosIpDscpMapArrayOutput) ToSwitchControllerQosIpDscpMapArrayOutputWithContext(ctx context.Context) SwitchControllerQosIpDscpMapArrayOutput {
	return o
}

func (o SwitchControllerQosIpDscpMapArrayOutput) Index(i pulumi.IntInput) SwitchControllerQosIpDscpMapOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SwitchControllerQosIpDscpMap {
		return vs[0].([]*SwitchControllerQosIpDscpMap)[vs[1].(int)]
	}).(SwitchControllerQosIpDscpMapOutput)
}

type SwitchControllerQosIpDscpMapMapOutput struct{ *pulumi.OutputState }

func (SwitchControllerQosIpDscpMapMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SwitchControllerQosIpDscpMap)(nil)).Elem()
}

func (o SwitchControllerQosIpDscpMapMapOutput) ToSwitchControllerQosIpDscpMapMapOutput() SwitchControllerQosIpDscpMapMapOutput {
	return o
}

func (o SwitchControllerQosIpDscpMapMapOutput) ToSwitchControllerQosIpDscpMapMapOutputWithContext(ctx context.Context) SwitchControllerQosIpDscpMapMapOutput {
	return o
}

func (o SwitchControllerQosIpDscpMapMapOutput) MapIndex(k pulumi.StringInput) SwitchControllerQosIpDscpMapOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SwitchControllerQosIpDscpMap {
		return vs[0].(map[string]*SwitchControllerQosIpDscpMap)[vs[1].(string)]
	}).(SwitchControllerQosIpDscpMapOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SwitchControllerQosIpDscpMapInput)(nil)).Elem(), &SwitchControllerQosIpDscpMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*SwitchControllerQosIpDscpMapArrayInput)(nil)).Elem(), SwitchControllerQosIpDscpMapArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SwitchControllerQosIpDscpMapMapInput)(nil)).Elem(), SwitchControllerQosIpDscpMapMap{})
	pulumi.RegisterOutputType(SwitchControllerQosIpDscpMapOutput{})
	pulumi.RegisterOutputType(SwitchControllerQosIpDscpMapArrayOutput{})
	pulumi.RegisterOutputType(SwitchControllerQosIpDscpMapMapOutput{})
}
